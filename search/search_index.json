{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AWorld Developer Platform","text":"<p>Use the AWorld API to build stateful agents, complex workflows, and multi-agent systems that can learn and evolve. AWorld provides a robust framework for agent orchestration and reinforcement learning integration.</p>"},{"location":"#get-started","title":"Get started","text":"<p>Quickstart Build your first agent in 5 minutes with Python.</p> <p>Core concepts Understand Agents, Swarms, and how AWorld manages state.</p> <p>Guides Step-by-step instructions for memory design, tools, multi-agent systems, and training.</p>"},{"location":"#build-deploy-and-scale","title":"Build, deploy, and scale","text":"<p>Building Agents Working code examples for common use cases and agent patterns.</p> <p>Orchestration Learn how to build complex Workflows and Multi-Agent Systems.</p> <p>Training Integrate with Reinforcement Learning frameworks like Verl to train your agents.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This guide will show you how to install AWorld and build your first agent.</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>Git</li> </ul>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>Install AWorld directly from the source:</p> <pre><code>git clone https://github.com/inclusionAI/AWorld &amp;&amp; cd AWorld\npip install .\n</code></pre>"},{"location":"quickstart/#build-your-first-agent","title":"Build your first Agent","text":"<p>Let's create a simple agent named <code>my_agent</code>.</p>"},{"location":"quickstart/#1-basic-setup","title":"1. Basic Setup","text":"<p>Create a file named <code>hello_world.py</code> and add the following code:</p> <pre><code>from aworld.agents.llm_agent import Agent\n\n# Assign a name to your agent\nagent = Agent(name=\"my_agent\")\n\nprint(f\"Agent {agent.name} created successfully!\")\n</code></pre>"},{"location":"quickstart/#2-configure-llm","title":"2. Configure LLM","text":"<p>You can configure the LLM provider using environment variables. This is the quickest way to get started.</p> <pre><code>import os\nfrom aworld.agents.llm_agent import Agent\n\n# Set up LLM service using environment variables\nos.environ[\"LLM_PROVIDER\"] = \"openai\"  # Choose from: openai, anthropic, azure_openai\nos.environ[\"LLM_MODEL_NAME\"] = \"gpt-4\"\nos.environ[\"LLM_API_KEY\"] = \"your-api-key\"\n# os.environ[\"LLM_BASE_URL\"] = \"https://api.openai.com/v1\"  # Optional\n\nagent = Agent(name=\"my_agent\")\n</code></pre>"},{"location":"quickstart/#3-run-your-agent","title":"3. Run your Agent","text":"<p>You can now interact with your agent. (Assuming an interactive run method exists or adding a simple print to verify configuration).</p> <pre><code># Simple verification\nprint(f\"Agent '{agent.name}' is ready to use with {os.environ['LLM_MODEL_NAME']}.\")\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic agent, learn how to:</p> <ul> <li>Customize your Agent with system prompts and configurations.</li> <li>Add Tools to give your agent capabilities.</li> <li>Build Workflows to chain multiple agents together.</li> </ul>"},{"location":"agents/building_agents/","title":"Building Stateful Agents","text":"<p>This guide covers the core aspects of configuring and customizing an AWorld Agent.</p>"},{"location":"agents/building_agents/#configuration","title":"Configuration","text":"<p>Agents are highly configurable entities. You can define their LLM backend, system prompts, and behavior policies.</p>"},{"location":"agents/building_agents/#basic-configuration","title":"Basic Configuration","text":"<pre><code>from aworld.agents.llm_agent import Agent\nfrom aworld.config.conf import AgentConfig\n\nagent_config = AgentConfig(\n    llm_provider=\"openai\",\n    llm_model_name=\"gpt-4\",\n    llm_api_key=\"sk-...\"\n)\n\nagent = Agent(name=\"my_agent\", conf=agent_config)\n</code></pre>"},{"location":"agents/building_agents/#system-prompts","title":"System Prompts","text":"<p>The <code>system_prompt</code> is the most critical part of your agent's persona. It defines who the agent is and how it should behave.</p> <pre><code>system_prompt = \"\"\"You are a coding assistant.\nAlways write clean, documented Python code.\nIf you are unsure, ask clarifying questions.\"\"\"\n\nagent = Agent(\n    name=\"coder\",\n    conf=agent_config,\n    system_prompt=system_prompt\n)\n</code></pre>"},{"location":"agents/building_agents/#customization","title":"Customization","text":"<p>AWorld allows you to override almost every stage of the agent's lifecycle.</p>"},{"location":"agents/building_agents/#custom-observation","title":"Custom Observation","text":"<p>Modify how the agent \"sees\" the world by overriding <code>init_observation</code>.</p> <pre><code>async def init_observation(self, observation: Observation) -&gt; Observation:\n    # Add timestamp or user context\n    observation.metadata = {\"timestamp\": time.time()}\n    return observation\n</code></pre>"},{"location":"agents/building_agents/#custom-model-logic","title":"Custom Model Logic","text":"<p>You don't have to use the default LLM call. You can override <code>invoke_model</code> to inject custom logic, rule-based systems, or call other models.</p> <pre><code>async def invoke_model(self, messages, **kwargs) -&gt; ModelResponse:\n    if self.use_rule_based_system:\n         return ModelResponse(content=\"Rule matched.\")\n    return await self.llm_client.chat_completion(messages)\n</code></pre>"},{"location":"agents/building_agents/#custom-output-parsing","title":"Custom Output Parsing","text":"<p>If your model outputs a specific format (e.g., JSON), you can implement a custom <code>ModelOutputParser</code>.</p> <pre><code>class JsonParser(ModelOutputParser):\n    async def parse(self, resp: ModelResponse, **kwargs) -&gt; AgentResult:\n        data = json.loads(resp.content)\n        return AgentResult(content=data['answer'])\n\nagent = Agent(..., model_output_parser=JsonParser())\n</code></pre>"},{"location":"agents/memory_and_context/","title":"Memory and Context","text":"<p>AWorld provides a sophisticated memory and context management system, powered by the AmniContext Engine. This system allows agents to maintain long-term state, understand hierarchical relationships, and retrieve relevant information efficiently.</p>"},{"location":"agents/memory_and_context/#context-hierarchy","title":"Context Hierarchy","text":"<p>Every task and agent in AWorld operates within a specific <code>Context</code>. These contexts are hierarchical, allowing for data isolation and inheritance.</p>"},{"location":"agents/memory_and_context/#context-levels","title":"Context Levels","text":"<ol> <li>Root Context: The top-level context for a user session or global task.</li> <li>Parent Context: The context of the agent or task that spawned the current operation.</li> <li>Current (Task) Context: The isolated runtime environment for the current agent.</li> </ol>"},{"location":"agents/memory_and_context/#referencing-context-in-prompts","title":"Referencing Context in Prompts","text":"<p>You can access context variables directly in your prompt templates using the <code>{{variable}}</code> syntax.</p> <ul> <li><code>{{current.status}}</code>: Access a variable from the current task.</li> <li><code>{{parent.goal}}</code>: Access a variable from the parent task.</li> <li><code>{{root.user_id}}</code>: Access a global variable.</li> </ul>"},{"location":"agents/memory_and_context/#memory-systems","title":"Memory Systems","text":"<p>The <code>Memory</code> module organizes information into three main categories:</p> <ol> <li>Working Memory: Stores active task states, temporary variables, and current execution paths.</li> <li>Short-term Memory: Contains the immediate conversation history and recent tool outputs.</li> <li>Long-term Memory: Persists consolidated information, user profiles, and facts that span across sessions.</li> </ol>"},{"location":"agents/memory_and_context/#semantic-search","title":"Semantic Search","text":"<p>Agents can retrieve information from memory using hybrid search (vector + keyword).</p> <pre><code># Example internal usage\nrelevant_items = agent.memory.search(\n    query=\"What is the user's preference?\",\n    memory_type=\"user_profile\",\n    limit=5\n)\n</code></pre>"},{"location":"agents/memory_and_context/#automatic-context-pruning","title":"Automatic Context Pruning","text":"<p>To manage the LLM's context window, AmniContext supports Context Pruning. It automatically removes less relevant information while preserving critical instructions and summaries.</p>"},{"location":"agents/memory_and_context/#structured-output","title":"Structured Output","text":"<p>AWorld agents use internal protocols to ensure structured communication.</p> <ul> <li>ActionModel: Defines the structure for tool calls (tool name, arguments).</li> <li>AgentResult: A standard envelope for agent responses, containing the content, state, and executed actions.</li> </ul> <p>While you typically interact with high-level text, the underlying system enforces these structures to ensure reliability in multi-agent handoffs.</p>"},{"location":"agents/multi_agent_systems/","title":"Multi-Agent Systems","text":"<p>AWorld supports building complex systems where multiple agents collaborate to solve problems. We support both static Workflows and dynamic Multi-Agent Systems (MAS).</p>"},{"location":"agents/multi_agent_systems/#static-workflows","title":"Static Workflows","text":"<p>Workflows are deterministic. The path of execution is pre-defined.</p>"},{"location":"agents/multi_agent_systems/#sequential-pipeline","title":"Sequential Pipeline","text":"<p><code>Agent A -&gt; Agent B -&gt; Agent C</code></p> <pre><code>from aworld.core.agent.swarm import Swarm\nfrom aworld.runner import Runners\n\nswarm = Swarm([(agent1, agent2), (agent2, agent3)], root_agent=[agent1])\nRunners.run(input=\"start\", swarm=swarm)\n</code></pre>"},{"location":"agents/multi_agent_systems/#parallel-execution","title":"Parallel Execution","text":"<p>Agents run in parallel, and a barrier agent waits for results.</p> <pre><code># agent1 and agent2 run in parallel; agent3 waits for both\nswarm = Swarm([(agent1, agent3), (agent2, agent3)], root_agent=[agent1, agent2])\n</code></pre>"},{"location":"agents/multi_agent_systems/#dynamic-mas-handoffs","title":"Dynamic MAS (Handoffs)","text":"<p>In a dynamic system, agents decide at runtime who to talk to next. This is achieved using the <code>GraphBuildType.HANDOFF</code> mode.</p>"},{"location":"agents/multi_agent_systems/#configuration","title":"Configuration","text":"<pre><code>from aworld.core.agent.swarm import Swarm, GraphBuildType\n\n# Define the network of allowed connections\nswarm = Swarm(\n    topology=[(agent1, agent2), (agent2, agent3), (agent1, agent3)],\n    build_type=GraphBuildType.HANDOFF,\n    root_agent=[agent1]\n)\n</code></pre>"},{"location":"agents/multi_agent_systems/#how-it-works","title":"How it Works","text":"<ol> <li>Agent 1 receives a task.</li> <li>It processes the task and decides it needs Agent 2's help.</li> <li>It emits a handoff event.</li> <li>The runner routes the context to Agent 2.</li> </ol>"},{"location":"agents/multi_agent_systems/#advanced-orchestration","title":"Advanced Orchestration","text":""},{"location":"agents/multi_agent_systems/#hybrid-systems","title":"Hybrid Systems","text":"<p>You can nest a dynamic Swarm inside a static Workflow. For example, a \"Planning\" step (static) can trigger a \"Research Team\" (dynamic swarm), which then feeds into a \"Report Generator\" (static).</p>"},{"location":"agents/multi_agent_systems/#custom-routing","title":"Custom Routing","text":"<p>You can implement custom <code>Handlers</code> to control message routing logic precisely, enabling patterns like: *   Round Robin: Distribute tasks evenly. *   Broadcast: Send a message to all agents. *   Semantic Routing: Route based on embedding similarity.</p>"},{"location":"build_agents/configuration/","title":"Agent Configuration","text":"<p>AWorld offers flexible configuration options for Agents, allowing you to define model providers, API keys, and runtime behaviors.</p>"},{"location":"build_agents/configuration/#configuration-methods","title":"Configuration Methods","text":""},{"location":"build_agents/configuration/#1-environment-variables","title":"1. Environment Variables","text":"<p>The quickest way to configure agents.</p> Variable Description Example <code>LLM_PROVIDER</code> The model provider <code>openai</code>, <code>anthropic</code> <code>LLM_MODEL_NAME</code> The model ID <code>gpt-4</code>, <code>claude-3-opus</code> <code>LLM_API_KEY</code> API Key <code>sk-...</code> <code>LLM_BASE_URL</code> API Endpoint (Optional) <code>https://api.openai.com/v1</code>"},{"location":"build_agents/configuration/#2-agentconfig-object","title":"2. AgentConfig Object","text":"<p>For programmatic control per agent.</p> <pre><code>from aworld.config.conf import AgentConfig\n\nconfig = AgentConfig(\n    llm_provider=\"openai\",\n    llm_model_name=\"gpt-4\",\n    llm_api_key=\"sk-...\"\n)\n</code></pre>"},{"location":"build_agents/configuration/#3-shared-modelconfig","title":"3. Shared ModelConfig","text":"<p>Share a single model configuration across multiple agents.</p> <pre><code>from aworld.config.conf import ModelConfig\n\n# Define once\nshared_model = ModelConfig(\n    llm_provider=\"openai\",\n    llm_model_name=\"gpt-4\"\n)\n\n# Use everywhere\nagent1_config = AgentConfig(llm_config=shared_model)\nagent2_config = AgentConfig(llm_config=shared_model)\n</code></pre>"},{"location":"build_agents/configuration/#advanced-settings","title":"Advanced Settings","text":"<ul> <li><code>need_reset</code>: Whether to reset agent state on start.</li> <li><code>step_reset</code>: Whether to reset state between steps.</li> <li><code>use_tools_in_prompt</code>: Whether to inject tool descriptions into the prompt automatically.</li> </ul>"},{"location":"build_agents/llm_agents/","title":"LLM Agents","text":"<p>This guide explains how to build the most fundamental type of agent in AWorld: the LLM Agent.</p>"},{"location":"build_agents/llm_agents/#basic-agent","title":"Basic Agent","text":"<p>The <code>Agent</code> class serves as the primary interface for interacting with Large Language Models.</p> <pre><code>from aworld.agents.llm_agent import Agent\n\n# Create a simple agent\nagent = Agent(\n    name=\"simple_assistant\",\n    system_prompt=\"You are a helpful assistant.\"\n)\n</code></pre>"},{"location":"build_agents/llm_agents/#customizing-behavior","title":"Customizing Behavior","text":""},{"location":"build_agents/llm_agents/#system-prompt","title":"System Prompt","text":"<p>The system prompt sets the agent's persona and constraints.</p> <pre><code>system_prompt = \"\"\"\nYou are a technical writer.\n- Use clear, concise language.\n- Always provide code examples.\n\"\"\"\nagent = Agent(name=\"writer\", system_prompt=system_prompt)\n</code></pre>"},{"location":"build_agents/llm_agents/#custom-model-logic","title":"Custom Model Logic","text":"<p>You can override <code>invoke_model</code> to implement custom reasoning loops or call specialized models.</p> <pre><code>async def invoke_model(self, messages, **kwargs) -&gt; ModelResponse:\n    # Custom logic here\n    return await self.llm_client.chat_completion(messages)\n</code></pre>"},{"location":"build_agents/llm_agents/#custom-output-parsing","title":"Custom Output Parsing","text":"<p>Implement a <code>ModelOutputParser</code> to handle structured responses (e.g., JSON).</p> <pre><code>class JsonParser(ModelOutputParser):\n    async def parse(self, resp: ModelResponse, **kwargs) -&gt; AgentResult:\n        # Parse JSON logic\n        return AgentResult(...)\n</code></pre>"},{"location":"build_agents/multi_agent_systems/","title":"Multi-Agent Systems (MAS)","text":"<p>Unlike static Workflows, Multi-Agent Systems (MAS) in AWorld are designed for dynamic, real-time decision-making. Agents decide at runtime who to communicate with next based on conversation context.</p>"},{"location":"build_agents/multi_agent_systems/#dynamic-handoffs","title":"Dynamic Handoffs","text":"<p>This behavior is enabled by setting <code>build_type=GraphBuildType.HANDOFF</code> in the Swarm configuration.</p>"},{"location":"build_agents/multi_agent_systems/#basic-setup","title":"Basic Setup","text":"<pre><code>from aworld.core.agent.swarm import Swarm, GraphBuildType\n\n# Define the ALLOWED communication paths\n# Agent 1 CAN talk to Agent 2 and Agent 3\n# Agent 2 CAN talk to Agent 3\nswarm = Swarm(\n    topology=[(agent1, agent2), (agent2, agent3), (agent1, agent3)],\n    build_type=GraphBuildType.HANDOFF,\n    root_agent=[agent1]\n)\n\nRunners.run(input=\"Solve this complex problem\", swarm=swarm)\n</code></pre>"},{"location":"build_agents/multi_agent_systems/#execution-flow","title":"Execution Flow","text":"<ol> <li>Agent 1 receives the input.</li> <li>Based on its system prompt and the user query, it decides it cannot solve it alone.</li> <li>It chooses to call Agent 2.</li> <li>The system routes the context to Agent 2.</li> <li>Agent 2 performs its task and may return the result to Agent 1 or forward it to Agent 3.</li> </ol>"},{"location":"build_agents/multi_agent_systems/#hybrid-orchestration","title":"Hybrid Orchestration","text":"<p>You can combine static and dynamic patterns. A <code>Swarm</code> can treat another <code>Swarm</code> as a single node (or agent) in its topology.</p> <p>Example: A \"Manager\" agent (static workflow root) delegates to a \"Research Team\" (dynamic swarm).</p> <pre><code># Create the dynamic research team\nresearch_swarm = Swarm(\n    topology=[(researcher, critic), (critic, researcher)],\n    build_type=GraphBuildType.HANDOFF\n)\n\n# Create the static workflow\nworkflow = Swarm(\n    topology=[(manager, research_swarm), (research_swarm, writer)],\n    root_agent=[manager]\n)\n</code></pre>"},{"location":"build_agents/multi_agent_systems/#custom-routing-logic","title":"Custom Routing Logic","text":"<p>For advanced control, you can implement custom event handlers to override default routing logic.</p> <pre><code>from aworld.runners import HandlerFactory\nfrom aworld.runners.handler import DefaultHandler\n\n@HandlerFactory.register(name=\"custom_router\")\nclass CustomRouter(DefaultHandler):\n    async def _do_handle(self, message):\n        # Implement custom routing logic (e.g., Round Robin, Semantic Match)\n        pass\n\nagent = Agent(..., event_handler_name=\"custom_router\")\n</code></pre>"},{"location":"build_agents/workflows/","title":"Workflows","text":"<p>Workflows in AWorld represent static, pre-defined execution flows. They are used when the sequence of operations is deterministic and known in advance.</p>"},{"location":"build_agents/workflows/#defining-a-workflow","title":"Defining a Workflow","text":"<p>AWorld uses the <code>Swarm</code> concept to manage agent orchestration. For workflows, the <code>topology</code> parameter defines the data flow graph.</p>"},{"location":"build_agents/workflows/#sequential-pipeline","title":"Sequential Pipeline","text":"<p>Execute agents in a strict linear order: <code>Agent A -&gt; Agent B -&gt; Agent C</code>.</p> <pre><code>from aworld.core.agent.swarm import Swarm\nfrom aworld.runner import Runners\n\n# Define the sequence: agent1 -&gt; agent2 -&gt; agent3\n# The root_agent defines where the input starts\nswarm = Swarm(\n    topology=[(agent1, agent2), (agent2, agent3)],\n    root_agent=[agent1]\n)\n\nresult = Runners.run(input=\"start task\", swarm=swarm)\n</code></pre>"},{"location":"build_agents/workflows/#parallel-execution-with-barrier","title":"Parallel Execution with Barrier","text":"<p>Multiple agents execute simultaneously, and a subsequent agent waits for all of them to finish.</p> <p>Scenario: Agent 1 and Agent 2 research different topics in parallel, then Agent 3 summarizes both results.</p> <pre><code># agent1 and agent2 run in parallel\n# agent3 waits for BOTH agent1 and agent2 to complete\nswarm = Swarm(\n    topology=[(agent1, agent3), (agent2, agent3)],\n    root_agent=[agent1, agent2]\n)\n</code></pre>"},{"location":"build_agents/workflows/#parallel-multi-path","title":"Parallel Multi-Path","text":"<p>A single agent can distribute work to multiple downstream agents, which then converge.</p> <pre><code># agent1 sends to BOTH agent2 and agent3\n# agent4 waits for agent2 and agent3\nswarm = Swarm(\n    topology=[(agent1, agent2), (agent1, agent3), (agent2, agent4), (agent3, agent4)],\n    root_agent=[agent1]\n)\n</code></pre>"},{"location":"build_agents/workflows/#task-native-workflow","title":"Task Native Workflow","text":"<p>For distributed scenarios or when strict runtime isolation is required, use Task Native Workflows.</p> <pre><code>from aworld.core.task import Task, RunConfig\n\ntask1 = Task(input=\"start\", agent=agent1)\ntask2 = Task(agent=agent2)\n\n# Explicit dependency management\ntasks = [task1, task2]\nresult = Runners.run_task(tasks, RunConfig(sequence_dependent=True))\n</code></pre>"},{"location":"components/events/","title":"Events","text":"<p>AWorld is built on an Event-Driven Architecture. Communication between agents, tools, and the environment is handled via asynchronous messages (Events).</p>"},{"location":"components/events/#the-message-object","title":"The Message Object","text":"<p>The core unit of communication is the <code>Message</code> object.</p> <pre><code>class Message:\n    category: str       # Event type (e.g., \"agent_message\", \"tool_output\")\n    payload: Any        # The actual data (AgentResult, ToolResult, etc.)\n    sender: str         # ID of the sender\n    receiver: str       # ID of the intended receiver\n    session_id: str     # Correlation ID for the conversation\n    headers: Dict       # Metadata (context, timestamps)\n</code></pre>"},{"location":"components/events/#event-flow","title":"Event Flow","text":"<ol> <li>Action Generation: An Agent generates an action (e.g., call a tool).</li> <li>Event Emission: This action is wrapped in a <code>Message</code> and emitted.</li> <li>Event Routing: The <code>Runner</code> or <code>Swarm</code> logic decides who receives this event.</li> <li>Handling: The receiver (e.g., Tool Executor or another Agent) processes the event and emits a result event.</li> </ol>"},{"location":"components/events/#group-messages","title":"Group Messages","text":"<p>For parallel execution, AWorld uses <code>GroupMessage</code>.</p> <pre><code>from aworld.core.event.base import GroupMessage, TopicType\n\n# A message containing multiple actions to be executed in parallel\ngroup_msg = GroupMessage(\n    payload=[action1, action2, action3],\n    topic=TopicType.GROUP_ACTIONS\n)\n</code></pre>"},{"location":"components/events/#custom-event-handlers","title":"Custom Event Handlers","text":"<p>You can intercept and process events by implementing custom Handlers. This is useful for logging, monitoring, or implementing custom routing logic (see Build Agents &gt; Multi-Agent Systems).</p>"},{"location":"components/memory_and_context/","title":"Memory and Context","text":"<p>AWorld provides a sophisticated memory and context management system, powered by the AmniContext Engine. This system allows agents to maintain long-term state, understand hierarchical relationships, and retrieve relevant information efficiently.</p>"},{"location":"components/memory_and_context/#context-hierarchy","title":"Context Hierarchy","text":"<p>Every task and agent in AWorld operates within a specific <code>Context</code>. These contexts are hierarchical, allowing for data isolation and inheritance.</p>"},{"location":"components/memory_and_context/#context-levels","title":"Context Levels","text":"<ol> <li>Root Context: The top-level context for a user session or global task.</li> <li>Parent Context: The context of the agent or task that spawned the current operation.</li> <li>Current (Task) Context: The isolated runtime environment for the current agent.</li> </ol>"},{"location":"components/memory_and_context/#referencing-context-in-prompts","title":"Referencing Context in Prompts","text":"<p>You can access context variables directly in your prompt templates using the <code>{{variable}}</code> syntax.</p> <ul> <li><code>{{current.status}}</code>: Access a variable from the current task.</li> <li><code>{{parent.goal}}</code>: Access a variable from the parent task.</li> <li><code>{{root.user_id}}</code>: Access a global variable.</li> </ul>"},{"location":"components/memory_and_context/#memory-systems","title":"Memory Systems","text":"<p>The <code>Memory</code> module organizes information into three main categories:</p> <ol> <li>Working Memory: Stores active task states, temporary variables, and current execution paths.</li> <li>Short-term Memory: Contains the immediate conversation history and recent tool outputs.</li> <li>Long-term Memory: Persists consolidated information, user profiles, and facts that span across sessions.</li> </ol>"},{"location":"components/memory_and_context/#semantic-search","title":"Semantic Search","text":"<p>Agents can retrieve information from memory using hybrid search (vector + keyword).</p> <pre><code># Example internal usage\nrelevant_items = agent.memory.search(\n    query=\"What is the user's preference?\",\n    memory_type=\"user_profile\",\n    limit=5\n)\n</code></pre>"},{"location":"components/memory_and_context/#automatic-context-pruning","title":"Automatic Context Pruning","text":"<p>To manage the LLM's context window, AmniContext supports Context Pruning. It automatically removes less relevant information while preserving critical instructions and summaries.</p>"},{"location":"components/memory_and_context/#structured-output","title":"Structured Output","text":"<p>AWorld agents use internal protocols to ensure structured communication.</p> <ul> <li>ActionModel: Defines the structure for tool calls (tool name, arguments).</li> <li>AgentResult: A standard envelope for agent responses, containing the content, state, and executed actions.</li> </ul> <p>While you typically interact with high-level text, the underlying system enforces these structures to ensure reliability in multi-agent handoffs.</p>"},{"location":"core_concepts/agents/","title":"Agents","text":"<p>In AWorld, an Agent is the fundamental building block of any system, whether it's a simple chatbot, a linear workflow, or a complex multi-agent system.</p>"},{"location":"core_concepts/agents/#what-is-an-agent","title":"What is an Agent?","text":"<p>An Agent in AWorld is a stateful entity that can: 1.  Observe its environment (<code>Observation</code>). 2.  Process information using an LLM or custom logic (<code>Policy</code>). 3.  Act by calling tools or sending messages (<code>Action</code>).</p> <p>The primary implementation provided is <code>llm_agent.Agent</code>, which wraps a Large Language Model to handle reasoning and decision-making.</p>"},{"location":"core_concepts/agents/#key-components","title":"Key Components","text":""},{"location":"core_concepts/agents/#1-configuration-agentconfig","title":"1. Configuration (<code>AgentConfig</code>)","text":"<p>Agents are highly configurable. You can define the LLM provider (OpenAI, Anthropic, etc.), model parameters, and API keys. This configuration can be individual per agent or shared via a <code>ModelConfig</code>.</p>"},{"location":"core_concepts/agents/#2-system-prompt","title":"2. System Prompt","text":"<p>The system prompt defines the agent's persona, constraints, and instructions. It sets the context for all interactions.</p>"},{"location":"core_concepts/agents/#3-tools","title":"3. Tools","text":"<p>Agents can be equipped with tools to interact with the outside world. AWorld supports: - Local Tools: Python functions decorated with <code>@be_tool</code>. - MCP Tools: Tools compliant with the Model Context Protocol (MCP). - Agent as Tool: Other agents can be registered as tools, allowing for hierarchical delegation.</p>"},{"location":"core_concepts/agents/#lifecycle","title":"Lifecycle","text":"<p>An agent's lifecycle involves receiving a <code>Message</code> or <code>Observation</code>, transforming it for the model, invoking the model, parsing the output, and executing actions. This entire loop is customizable via methods like <code>async_messages_transform</code>, <code>invoke_model</code>, and <code>async_post_run</code>.</p>"},{"location":"core_concepts/mas/","title":"Multi-Agent Systems (MAS)","text":"<p>While Workflows handle static processes, Multi-Agent Systems (MAS) in AWorld are designed for dynamic, real-time decision-making.</p>"},{"location":"core_concepts/mas/#dynamic-handoffs","title":"Dynamic Handoffs","text":"<p>In a MAS, the flow of execution is not hardcoded. Instead, agents decide at runtime who to talk to next based on the conversation context. This is achieved using the <code>GraphBuildType.HANDOFF</code> mode in a <code>Swarm</code>.</p> <ul> <li>Agent A receives a query.</li> <li>Agent A decides it needs help from Agent B.</li> <li>Agent A \"hands off\" the task to Agent B.</li> <li>Agent B performs the task and may hand back to A or forward to Agent C.</li> </ul>"},{"location":"core_concepts/mas/#event-driven-architecture","title":"Event-Driven Architecture","text":"<p>MAS in AWorld relies on an event mechanism. The output of one agent serves as the input for the next, facilitating complex interaction patterns.</p>"},{"location":"core_concepts/mas/#routing-topology","title":"Routing &amp; Topology","text":"<p>Even in a dynamic system, you define a Topology\u2014a set of allowed connections. For example, you might allow the \"Manager\" to talk to \"Worker A\" and \"Worker B\", but prevent \"Worker A\" from talking directly to \"Worker B\".</p> <p>AWorld supports complex routing logic, allowing you to override default behaviors and implement custom routing protocols (e.g., Round Robin, Broadcast, or Semantic Routing).</p>"},{"location":"core_concepts/workflows/","title":"Workflows","text":"<p>Workflows in AWorld represent static, pre-defined execution flows. They are used when the sequence of operations is deterministic and known in advance.</p>"},{"location":"core_concepts/workflows/#the-swarm-concept","title":"The Swarm Concept","text":"<p>AWorld uses the concept of a <code>Swarm</code> to manage collections of agents. For workflows, a Swarm is defined with a specific topology that dictates how data flows between agents.</p>"},{"location":"core_concepts/workflows/#types-of-workflows","title":"Types of Workflows","text":"<p>AWorld supports classic graph syntaxes to describe workflows:</p>"},{"location":"core_concepts/workflows/#sequential","title":"Sequential","text":"<p>A linear pipeline where the output of one agent becomes the input of the next. <code>Agent A -&gt; Agent B -&gt; Agent C</code></p>"},{"location":"core_concepts/workflows/#parallel-with-barrier","title":"Parallel with Barrier","text":"<p>Multiple agents execute simultaneously, and a subsequent agent waits for all of them to finish before proceeding. This is useful for tasks like \"researching multiple topics at once and then summarizing them.\"</p>"},{"location":"core_concepts/workflows/#parallel-multi-path","title":"Parallel Multi-Path","text":"<p>A mix of sequential and parallel paths. An agent can distribute work to multiple downstream agents, which then converge later.</p>"},{"location":"core_concepts/workflows/#task-native-workflow","title":"Task Native Workflow","text":"<p>For scenarios requiring strict isolation of runtimes and environments (e.g., distributed systems), AWorld provides Task Native Workflows. These wrap agents in <code>Task</code> objects and manage execution dependencies explicitly.</p>"},{"location":"guides/building_agents/","title":"Building Agents","text":"<p>This guide provides detailed instructions on how to configure, customize, and extend Agents in AWorld.</p>"},{"location":"guides/building_agents/#configuration","title":"Configuration","text":""},{"location":"guides/building_agents/#using-environment-variables","title":"Using Environment Variables","text":"<p>The simplest way to configure an agent is via environment variables.</p> <pre><code>import os\nfrom aworld.agents.llm_agent import Agent\n\nos.environ[\"LLM_PROVIDER\"] = \"openai\"\nos.environ[\"LLM_MODEL_NAME\"] = \"gpt-4\"\nos.environ[\"LLM_API_KEY\"] = \"sk-...\"\n# os.environ[\"LLM_BASE_URL\"] = \"...\" # Optional\n\nagent = Agent(name=\"simple_agent\")\n</code></pre>"},{"location":"guides/building_agents/#using-agentconfig","title":"Using AgentConfig","text":"<p>For more control, use <code>AgentConfig</code>.</p> <pre><code>from aworld.agents.llm_agent import Agent\nfrom aworld.config.conf import AgentConfig\n\nagent_config = AgentConfig(\n    llm_provider=\"openai\",\n    llm_model_name=\"gpt-4\",\n    llm_api_key=\"sk-...\"\n)\n\nagent = Agent(name=\"configured_agent\", conf=agent_config)\n</code></pre>"},{"location":"guides/building_agents/#shared-model-configuration","title":"Shared Model Configuration","text":"<p>If multiple agents share the same LLM settings, use <code>ModelConfig</code>.</p> <pre><code>from aworld.config.conf import AgentConfig, ModelConfig\n\nmodel_config = ModelConfig(\n    llm_provider=\"openai\",\n    llm_model_name=\"gpt-4\",\n    llm_api_key=\"sk-...\"\n)\n\nagent_config = AgentConfig(llm_config=model_config)\nagent = Agent(name=\"shared_agent\", conf=agent_config)\n</code></pre>"},{"location":"guides/building_agents/#system-prompts","title":"System Prompts","text":"<p>Define the agent's behavior using the <code>system_prompt</code> parameter.</p> <pre><code>system_prompt = \"\"\"You are a helpful AI assistant.\nYou should be polite, accurate, and provide clear explanations.\"\"\"\n\nagent = Agent(\n    name=\"polite_agent\",\n    conf=agent_config,\n    system_prompt=system_prompt\n)\n</code></pre>"},{"location":"guides/building_agents/#configuring-tools","title":"Configuring Tools","text":""},{"location":"guides/building_agents/#local-tools","title":"Local Tools","text":"<p>Turn Python functions into tools using the <code>@be_tool</code> decorator.</p> <pre><code>from aworld.core.tool.func_to_tool import be_tool\n\n@be_tool(tool_name='greeting_tool', tool_desc=\"Returns a hello message\")\ndef greeting_tool() -&gt; str:\n    return \"Hello, world!\"\n\nagent = Agent(\n    name=\"tool_agent\",\n    conf=agent_config,\n    tool_names=['greeting_tool']\n)\n</code></pre>"},{"location":"guides/building_agents/#mcp-tools","title":"MCP Tools","text":"<p>Connect to Model Context Protocol (MCP) servers.</p> <pre><code>mcp_config = {\n    \"mcpServers\": {\n        \"Filesystem\": {\n            \"type\": \"stdio\",\n            \"command\": \"python\",\n            \"args\": [\"path/to/mcp_server.py\"],\n        },\n    }\n}\n\nagent = Agent(\n    name=\"mcp_agent\",\n    conf=agent_config,\n    mcp_servers=[\"Filesystem\"],\n    mcp_config=mcp_config\n)\n</code></pre>"},{"location":"guides/building_agents/#agent-as-tool","title":"Agent as Tool","text":"<p>An agent can use another agent as a tool.</p> <pre><code>worker_agent = Agent(name=\"worker\", conf=agent_config)\n\nmanager_agent = Agent(\n    name=\"manager\",\n    conf=agent_config,\n    agent_names=['worker']\n)\n</code></pre>"},{"location":"guides/building_agents/#customization","title":"Customization","text":"<p>AWorld allows you to override core agent behaviors.</p>"},{"location":"guides/building_agents/#custom-observation","title":"Custom Observation","text":"<p>Modify <code>init_observation</code> to enrich input data.</p> <pre><code>async def init_observation(self, observation: Observation) -&gt; Observation:\n    observation.metadata = {\"timestamp\": time.time()}\n    return observation\n</code></pre>"},{"location":"guides/building_agents/#custom-model-logic","title":"Custom Model Logic","text":"<p>Override <code>invoke_model</code> to use non-LLM logic or custom models.</p> <pre><code>async def invoke_model(self, messages, **kwargs) -&gt; ModelResponse:\n    if self.use_custom_logic:\n         return ModelResponse(content=\"Custom logic result\", model=\"custom\")\n    return await self.llm_client.chat_completion(messages)\n</code></pre>"},{"location":"guides/building_agents/#custom-output-parser","title":"Custom Output Parser","text":"<p>Implement <code>ModelOutputParser</code> to handle custom model responses.</p> <pre><code>class CustomParser(ModelOutputParser):\n    async def parse(self, resp: ModelResponse, **kwargs) -&gt; AgentResult:\n        # Custom parsing logic\n        return AgentResult(content=resp.content)\n\nagent = Agent(..., model_output_parser=CustomParser())\n</code></pre>"},{"location":"guides/orchestration/","title":"Orchestration: Workflows &amp; MAS","text":"<p>This guide covers how to connect multiple agents to build Workflows and Multi-Agent Systems (MAS).</p>"},{"location":"guides/orchestration/#workflows-static-topology","title":"Workflows (Static Topology)","text":"<p>Workflows are useful for deterministic processes.</p>"},{"location":"guides/orchestration/#sequential","title":"Sequential","text":"<p>Execute agents in a strict order: Agent A -&gt; Agent B.</p> <pre><code>from aworld.core.agent.swarm import Swarm\nfrom aworld.runner import Runners\n\n# Define the sequence\nswarm = Swarm([(agent1, agent2), (agent2, agent3)], root_agent=[agent1])\nRunners.run(input=\"start\", swarm=swarm)\n</code></pre>"},{"location":"guides/orchestration/#parallel","title":"Parallel","text":"<p>Agents run simultaneously, synchronizing at a specific point.</p> <pre><code># agent1 and agent2 run in parallel, agent3 waits for both\nswarm = Swarm([(agent1, agent3), (agent2, agent3)], root_agent=[agent1, agent2])\nRunners.run(input=\"start\", swarm=swarm)\n</code></pre>"},{"location":"guides/orchestration/#multi-agent-systems-dynamic-handoff","title":"Multi-Agent Systems (Dynamic Handoff)","text":"<p>MAS allows agents to decide the control flow dynamically.</p>"},{"location":"guides/orchestration/#basic-setup","title":"Basic Setup","text":"<p>Use <code>GraphBuildType.HANDOFF</code> to enable dynamic routing.</p> <pre><code>from aworld.core.agent.swarm import Swarm, GraphBuildType\n\n# Define allowed communication paths\nswarm = Swarm(\n    topology=[(agent1, agent2), (agent2, agent3), (agent1, agent3)],\n    build_type=GraphBuildType.HANDOFF,\n    root_agent=[agent1]\n)\n\nRunners.run(input=\"your question\", swarm=swarm)\n</code></pre>"},{"location":"guides/orchestration/#hybrid-systems","title":"Hybrid Systems","text":"<p>You can nest Swarms to combine static workflows with dynamic MAS.</p> <pre><code># MAS handles complex planning\nmas_team = Swarm(..., build_type=GraphBuildType.HANDOFF)\n\n# Workflow wraps the MAS team\nworkflow = Swarm(\n    topology=[(preprocess_agent, mas_team), (mas_team, summary_agent)],\n    root_agent=[preprocess_agent]\n)\n</code></pre>"},{"location":"guides/orchestration/#advanced-routing","title":"Advanced Routing","text":""},{"location":"guides/orchestration/#custom-handlers","title":"Custom Handlers","text":"<p>You can implement custom event handlers to control exactly how messages are routed between agents.</p> <pre><code>from aworld.runners import HandlerFactory\nfrom aworld.runners.handler import DefaultHandler\n\n@HandlerFactory.register(name=\"custom_router\")\nclass CustomRouter(DefaultHandler):\n    async def _do_handle(self, message):\n        # Your custom routing logic here\n        pass\n\nagent = Agent(..., event_handler_name=\"custom_router\")\n</code></pre>"},{"location":"guides/orchestration/#examples-react-and-plan-execute","title":"Examples: ReAct and Plan-Execute","text":"<p>AWorld includes built-in patterns for complex reasoning.</p> <ul> <li>ReAct: Standard Reason-Act loop.</li> <li>Plan-Execute: Separates planning from execution, allowing parallel execution of planned steps.</li> </ul>"},{"location":"guides/training/","title":"Training Agents","text":"<p>AWorld allows you to train agents using Reinforcement Learning (RL) by integrating with frameworks like Verl.</p>"},{"location":"guides/training/#architecture","title":"Architecture","text":"<p>The training pipeline consists of: 1.  Environment (<code>env</code>): The problem space (e.g., Gaia benchmark). 2.  Agent: Your AWorld agent. 3.  Adapter: Bridges AWorld Agent with the training framework. 4.  Training Framework (<code>verl</code>): Manages the RL loop (PPO, etc.).</p>"},{"location":"guides/training/#environment-setup","title":"Environment Setup","text":""},{"location":"guides/training/#1-requirements","title":"1. Requirements","text":"<ul> <li>Linux (recommended) with NVIDIA GPU.</li> <li>Docker &amp; Nvidia Container Toolkit.</li> <li>Python 3.11+.</li> </ul>"},{"location":"guides/training/#2-launch-gaia-environment","title":"2. Launch Gaia Environment","text":"<p>AWorld provides a dockerized environment for the Gaia benchmark.</p> <p><pre><code>cd ~/AWorld/env\nsh run-local.sh\n</code></pre> This starts an MCP server at <code>http://localhost:8000/mcp</code>.</p>"},{"location":"guides/training/#building-a-trainable-agent","title":"Building a Trainable Agent","text":"<p>To train an agent, you need to implement a custom <code>AgentLoop</code>.</p> <pre><code>from train.adapter.verl.aworld_agent_loop import AworldAgentLoop\n\nclass MyTrainableLoop(AworldAgentLoop):\n    def build_agents(self):\n        # Configure your agent to use the training environment's LLM\n        return Agent(\n            name=\"trainable_agent\",\n            conf=AgentConfig(\n                llm_base_url=self.get_llm_server_address(),\n                llm_model_name=self.get_llm_server_model_name(),\n                llm_api_key=\"dummy\"\n            ),\n            # Connect to the environment's tools\n            mcp_config=self.env_config,\n            mcp_servers=self.env_servers\n        )\n</code></pre>"},{"location":"guides/training/#running-the-training","title":"Running the Training","text":""},{"location":"guides/training/#1-reward-function","title":"1. Reward Function","text":"<p>Define a reward function to evaluate your agent's performance.</p> <pre><code>def my_reward_func(data_source, solution, ground_truth):\n    if solution == ground_truth:\n        return 1.0\n    return 0.0\n</code></pre>"},{"location":"guides/training/#2-configuration-launch","title":"2. Configuration &amp; Launch","text":"<p>Update <code>agent.yaml</code> to point to your <code>MyTrainableLoop</code> and run the training script.</p> <pre><code># Example command (simplified)\nbash run.sh \\\n    agent_loop_config_path=path/to/agent.yaml \\\n    reward_fn_name=my_reward_func\n</code></pre> <p>See the full <code>run.sh</code> in the <code>train/examples</code> directory for all hyperparameters (learning rate, batch size, etc.).</p>"},{"location":"tools/built_in_tools/","title":"Connecting Agents to Tools","text":"<p>Agents in AWorld can be equipped with tools to interact with the outside world. This guide explains how to create local tools and connect them to your agents.</p>"},{"location":"tools/built_in_tools/#local-tools","title":"Local Tools","text":"<p>The simplest way to add capability to an agent is by defining a Python function and decorating it with <code>@be_tool</code>.</p>"},{"location":"tools/built_in_tools/#1-define-the-tool","title":"1. Define the Tool","text":"<pre><code>from aworld.core.tool.func_to_tool import be_tool\n\n@be_tool(tool_name='greeting_tool', tool_desc=\"Returns a hello message\")\ndef greeting_tool(name: str) -&gt; str:\n    \"\"\"\n    A simple tool that greets the user.\n    Args:\n        name: The name of the person to greet.\n    \"\"\"\n    return f\"Hello, {name}!\"\n</code></pre>"},{"location":"tools/built_in_tools/#2-register-with-agent","title":"2. Register with Agent","text":"<p>Pass the tool name in the <code>tool_names</code> list when initializing the Agent.</p> <pre><code>from aworld.agents.llm_agent import Agent\n\nagent = Agent(\n    name=\"tool_agent\",\n    tool_names=['greeting_tool']\n    # ... other config\n)\n</code></pre>"},{"location":"tools/built_in_tools/#agent-as-tool","title":"Agent as Tool","text":"<p>AWorld supports a hierarchical structure where one agent can use another agent as a tool. This is useful for delegating sub-tasks.</p> <pre><code># The \"worker\" agent\nworker = Agent(name=\"worker\", system_prompt=\"I do the actual work.\")\n\n# The \"manager\" agent\nmanager = Agent(\n    name=\"manager\",\n    agent_names=['worker'], # Register the worker agent as a tool\n    system_prompt=\"I delegate tasks to my worker.\"\n)\n</code></pre>"},{"location":"tools/connecting_tools/","title":"Connecting Agents to Tools","text":"<p>Agents in AWorld can be equipped with tools to interact with the outside world. This guide explains how to create local tools and connect them to your agents.</p>"},{"location":"tools/connecting_tools/#local-tools","title":"Local Tools","text":"<p>The simplest way to add capability to an agent is by defining a Python function and decorating it with <code>@be_tool</code>.</p>"},{"location":"tools/connecting_tools/#1-define-the-tool","title":"1. Define the Tool","text":"<pre><code>from aworld.core.tool.func_to_tool import be_tool\n\n@be_tool(tool_name='greeting_tool', tool_desc=\"Returns a hello message\")\ndef greeting_tool(name: str) -&gt; str:\n    \"\"\"\n    A simple tool that greets the user.\n    Args:\n        name: The name of the person to greet.\n    \"\"\"\n    return f\"Hello, {name}!\"\n</code></pre>"},{"location":"tools/connecting_tools/#2-register-with-agent","title":"2. Register with Agent","text":"<p>Pass the tool name in the <code>tool_names</code> list when initializing the Agent.</p> <pre><code>from aworld.agents.llm_agent import Agent\n\nagent = Agent(\n    name=\"tool_agent\",\n    tool_names=['greeting_tool']\n    # ... other config\n)\n</code></pre>"},{"location":"tools/connecting_tools/#agent-as-tool","title":"Agent as Tool","text":"<p>AWorld supports a hierarchical structure where one agent can use another agent as a tool. This is useful for delegating sub-tasks.</p> <pre><code># The \"worker\" agent\nworker = Agent(name=\"worker\", system_prompt=\"I do the actual work.\")\n\n# The \"manager\" agent\nmanager = Agent(\n    name=\"manager\",\n    agent_names=['worker'], # Register the worker agent as a tool\n    system_prompt=\"I delegate tasks to my worker.\"\n)\n</code></pre>"},{"location":"tools/mcp/","title":"Model Context Protocol (MCP)","text":"<p>AWorld has native support for the Model Context Protocol (MCP), allowing agents to connect to any MCP-compliant server.</p>"},{"location":"tools/mcp/#what-is-mcp","title":"What is MCP?","text":"<p>MCP is an open standard that enables AI models to interact with external data and tools in a unified way. Instead of writing custom integrations for every data source (like Google Drive, Slack, or a local filesystem), you can use an MCP server.</p>"},{"location":"tools/mcp/#configuring-mcp-servers","title":"Configuring MCP Servers","text":"<p>You can connect an AWorld agent to one or more MCP servers using the <code>mcp_config</code> parameter.</p>"},{"location":"tools/mcp/#example-connecting-to-a-filesystem-server","title":"Example: Connecting to a Filesystem Server","text":"<pre><code>from aworld.agents.llm_agent import Agent\nfrom aworld.config.conf import AgentConfig\n\n# Define the MCP configuration\nmcp_config = {\n    \"mcpServers\": {\n        \"Filesystem\": {\n            \"type\": \"stdio\",\n            \"command\": \"python\",\n            \"args\": [\"path/to/mcp_server.py\"],\n        },\n    }\n}\n\n# Create agent with MCP support\nagent = Agent(\n    name=\"mcp_agent\",\n    conf=AgentConfig(...),\n    mcp_servers=[\"Filesystem\"], # List of servers to enable\n    mcp_config=mcp_config\n)\n</code></pre>"},{"location":"tools/mcp/#using-gaia-environment-mcp","title":"Using Gaia Environment (MCP)","text":"<p>AWorld provides a pre-configured Gaia environment that runs multiple MCP servers (web search, browser automation, document reading, etc.).</p> <pre><code>from train.adapter.verl.common import get_agent_tool_env_and_servers\n\n# Get auto-configured environment settings\nenv_config, env_servers = get_agent_tool_env_and_servers()\n\nagent = Agent(\n    name=\"gaia_agent\",\n    mcp_config=env_config,\n    mcp_servers=env_servers\n)\n</code></pre>"},{"location":"training/rl_training/","title":"Reinforcement Learning Training","text":"<p>A unique feature of AWorld is its native integration with Reinforcement Learning (RL) frameworks like Verl, allowing you to optimize agent policies through interaction.</p>"},{"location":"training/rl_training/#architecture","title":"Architecture","text":"<p>The training pipeline connects your AWorld Agent to an RL environment (like the Gaia benchmark).</p> <ol> <li>Environment: Simulates the world (e.g., a Docker container with web access).</li> <li>Agent: The AWorld agent being trained.</li> <li>Adapter: Bridges the agent's <code>ActionModel</code> outputs to the RL framework's action space.</li> </ol>"},{"location":"training/rl_training/#training-workflow","title":"Training Workflow","text":""},{"location":"training/rl_training/#1-prepare-the-environment","title":"1. Prepare the Environment","text":"<p>Use the provided scripts to launch the Gaia environment (MCP server + Docker).</p> <pre><code>cd ~/AWorld/env\nsh run-local.sh\n</code></pre>"},{"location":"training/rl_training/#2-implement-agentloop","title":"2. Implement AgentLoop","text":"<p>Create a custom <code>AgentLoop</code> that defines how your agent interacts with the environment during training steps.</p> <pre><code>from train.adapter.verl.aworld_agent_loop import AworldAgentLoop\n\nclass GaiaAgentLoop(AworldAgentLoop):\n    def build_agents(self):\n        # Connect agent to the training environment's tools\n        return Agent(..., mcp_config=self.env_config)\n</code></pre>"},{"location":"training/rl_training/#3-define-reward-function","title":"3. Define Reward Function","text":"<p>Create a function that evaluates the agent's performance.</p> <pre><code>def reward_func(solution, ground_truth):\n    # Return 1.0 for success, 0.0 for failure\n    return 1.0 if solution == ground_truth else 0.0\n</code></pre>"},{"location":"training/rl_training/#4-run-training","title":"4. Run Training","text":"<p>Execute the training script (e.g., <code>run.sh</code>), which uses PPO (Proximal Policy Optimization) to update the agent's weights based on the reward signal.</p>"}]}